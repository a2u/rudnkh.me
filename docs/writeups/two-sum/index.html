<!doctype html><html lang=en><head><meta charset=utf-8><title>vit ✨</title><meta name=robots content="index, follow"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name=description content="Vitalii Rudnykh"><meta property="og:title" content="Vitalii Rudnykh"><meta property="og:description" content="A tech enthusiast"><meta property="og:url" content="https://rudnkh.me"><meta name=twitter:card content="summary"><meta name=twitter:site content="@rudnkh"><meta name=twitter:creator content="@rudnkh"><meta name=twitter:title content="Vitaliy Rudnykh @rudnkh"><meta name=twitter:description content="A tech enthusiast"><link rel="shortcut icon" href=favicon.ico><link rel="shortcut icon" href=/favicon.ico><link href=/css/style.css rel=stylesheet><script>console.log("Follow the white rabbit.")</script></head><body><div id=root><header class="measure section"><small><a href=/>rudnkh.me</a> / <a href=/writeups>writeups</a></small><div class=section><h1>Two Sum</h1><div class=game-info><p><strong>Platform:</strong> LeetCode</p><p><strong>Date:</strong> 22 Nov 2025</p><p><strong>Tags:</strong> array, hash-table</p></div><h2 id=problem>Problem</h2><p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.</p><h2 id=solution>Solution</h2><p>The brute force approach would be O(n²), but we can optimize it using a hash table to achieve O(n) time complexity.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>twoSum</span>(nums, target):
</span></span><span style=display:flex><span>    seen <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, num <span style=color:#f92672>in</span> enumerate(nums):
</span></span><span style=display:flex><span>        complement <span style=color:#f92672>=</span> target <span style=color:#f92672>-</span> num
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> complement <span style=color:#f92672>in</span> seen:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> [seen[complement], i]
</span></span><span style=display:flex><span>        seen[num] <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> []
</span></span></code></pre></div><h2 id=complexity>Complexity</h2><ul><li><strong>Time:</strong> O(n) - single pass through the array</li><li><strong>Space:</strong> O(n) - hash table storage</li></ul><h2 id=key-insights>Key Insights</h2><p>Using a hash table allows us to look up complements in constant time, reducing the overall complexity from O(n²) to O(n).</p></div></header><footer class="measure section footer"></footer></div></body></html>